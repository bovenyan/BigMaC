/*
 *  Author: Nanxi Kang (nkang@cs.princeton.edu)
 *  Institute: Princeton University
 *  Last updated on Feb.17th, 2014
 *
 *  All rights reserved.
 */
 
In this document, we explain the use of codes used to .
These codes are part of the Project "Optimizing One Big Switch Abstraction" in Princeton University.


We first introduce the source codes and the input file format needed to run the codes 


1. Graph algorithm (graph_algorithm/Opt_Big_Switch)
   1.1 Run command
     java Drive $OutputDir $PathPolicyFile $TopoFile [-i $start_iter $end_iter] [-e $eta_base $hops_base] [-p $process] [-f $path_executable]
     Example:
      java Drive ./result/ path_policy.txt topology.txt -e 1.1 4 -p 2 -f ../path
     
   1.2 Program overview:
     The program computes rule placement over multiple paths, given the path policies and the topology. The users must prepare the path policies to execute the program.
     It runs iteratively. In each iteration, it first gives an estimation ratio (\eta) for every path; \eta is used to compute the total number of rules needed by each path; the linear programming module (LP) is invoked to allocate rules to paths according to the estimation; path algorithm computes a feasible rule placement based on the allocation.
     If LP cannot satisfy the estimation, the program terminates and report "fail"; if the path algorithms find feasible rule placement for all paths, the program terminates and report "success". Otherwise, the program increase \eta for paths, which do not have a feasible rule placement, and repeat the iterations.
     
   1.3 Input specification:
     This program at minimum takes two inputs: (i) path policy and (ii) topology. Additional parameters are received to configure: (iii) path executable filename, (iv) the number of iterations, (v) the estimation ratios \eta and (v) the number of processes to run path algorithms.
     (i) PathPolicyFile specifies a list of path policies.
     (ii)TopoFile describes the rule capacity of switches in the network and the switches on the paths. 
     (iii) The program should be given the compiled executable of path algorithm (the source code is path.cpp in folder graph_algorithm/).
     (iv) By default, the program iteratively compute rule placement until all path algorithms succeed or no feasible solution exists (\eta for paths grows and exceeds the rule capacity). Setting the $start_iter and $end_iter allows controlling the number of iterations, as well as continuing from the ending iteration of the last run.
      (v) A list of \eta value are used to correct the estimation for each iteration of rule placement computation. To customize the estimation ratio, we use $eta_base, such that the list would be the powers of $eta_base, i.e., [1.0, $eta_base, $eta_base^2, ...]. Since the starting \eta value for every path is related to the path length, an additional argument $hop_base is used to select the initial eta for every path. Specifically, paths with length=1 start with \eta = 1; paths with length <= 1 + $hop_base start with \eta = $eta_base; paths with length <= 1 + 2 * $hop_base start with \eta = $eta_base ^ 2 and like wise.
      Suggested values for $eta_base and $hop_base are 1.1 and 5. But these values are subject to changes depending on the policy and topology.

   1.4 Output specification:
     In each iteration, the program writes the information of paths to several files.
     (i) RatioFile specifies the \eta for every path.
     (ii) PolicyNumFile specifies the total number of rules needed for every path.
     (iii) AllocFile specifies the rule allocation for paths.
     (iv) ResFile shows the rule placement result (success or fail) for every path.
   
   1.5 Execute single module
       1.5.1 Linear Program (Opt_Big_Switch/Allocate.java)
       1.5.2 Path algorithm (path.cpp)
        - Run command
           batch_DFS_MP $AllocFile $PathPolicyFile $ResultFile $num_process $kth_process $output_debug_info
           $num_process and $kth_process means the program should only compute the $kth_process part of all paths (there are $num_proess parts in total). IF YOU WANT TO COMPUTE ALL PATHS, USE $num_proess = 1 and $kth_process = 0.
           $output_debug_info = 0 means "Do not output any debug information"; otherwise, the program outputs all the selected rectangle for the switches on paths.
      
2. File format
   (*) Example files can be found in graph_algorithm/examples
   2.1 PathPolicyFile
       PathPolicyFile starts with the number of paths (n_path), followed by n_path blocks. Each block contains the index of the path, the number of rules for this path, and the rules (one rule per line). Please refer Section 3 for detailed interpretation of rules. A sample file is shown below:
       =======path_policy.txt========
       3
       0
       3
       8448953 16 1 1
       4364187 16 1 1
       8580724 16 1 0
       1
       5
       4286175 16 1 0
       8889832 16 1 1
       8424594 16 1 0
       17759734 16 1 1
       8572759 16 1 1
       2
       4
       4425046 16 1 0
       4441883 16 1 1
       4290240 16 1 1
       4290920 16 1 0
       ============================
       The sample specifies 3 paths. Path 0 contains 3 rules; Path 1 contains 5 rules; Path 2 contains 4 rules.
       
   2.2 TopoFile
       TopoFile starts with the number of switches (n_switch) and the number of paths(n_path) on the first line. The next line specifies the rule capacity of all switches, separated by space. Each following line specifies one path: the first value is the number of hops (n_hop), and the next n_hop numbers are the indexes of switches on the path in order. A sample file is shown below:
       =======topology.txt========
       2 4
       300 300 300 300
       3 0 1 3
       3 0 2 3
       ============================
       The sample shows a network of 4 switches and 2 paths. Path 0 contains 3 switches (0, 1 and 3); Path 1 contains 3 switches (0, 2 and 3). Each switch can receive 300 rules.
       
   2.3 ResFile
       ResFile starts with number of paths (n_path), followed by n_path lines. Each line shows the feasibility of rule placement  for the corresponding path(0 for fail and 1 for success).
   
   2.4 RatioFile
   	   RatioFile starts with number of paths (n_path). Each following line shows the eta for the corresponding path.
   
   2.5 PolicyNumFile
   	   PolicyNumFile starts with number of paths (n_path). Each following line shows the total number of rules needed by the corresponding path.
   
   2.6 AllocFile
       AllocFile starts with the number of paths(n_path). Each following line specifies the rule allocation for one path: the first value is the number of hops (n_hop), and the next n_hop numbers are the number of rules allocated by the switches in order. A sample file is shown below (corresponding to topology.txt):
       =======alloc.txt========
       2 
       3 150 300 0
       3 150 300 300
       ============================
       The sample shows one rule allocation corresponding to the topology in Topology.txt. Namely, both paths are give 150 rules by switch 0; Path 0 gets 300 rules from switch 1; Path 1 gets 300 rules from switch 2 and switch 3.

3. Policy conversion tools (format_converter)
   We provide tools to convert rules in other formats to our input policy. Cisco/ translates ACL clauses; transform_cb translates ClassBench rules.   
   3.1. Convert ACL (Cisco\)
   	Command:
	  java CiscoDrive $acl $result $literal_port.csv
   	Example (director = ./Cisco):
     	  java CiscoDrive acl.txt output.txt literal_port.csv

   3.2. Convert ClassBench (transform_cb.cpp)
        Translate pattern and randomly generate actions
        Command:
          transform_cb $classbench_file $result $num_actions
        Example: 
          transform_cb acl1_10k acl1_10k.txt 2
   (*) Example files can be found in folder format_converter/examples/

   3.3 We briefly explain the representation of rule
       To map one prefix pattern to an integer, we define a recursive function F(p) to translate a prefix matching pattern p to an integer:
      F(*) = 0
      F(p0) = 2F(p) + 1
      F(p1) = 2F(p) + 2
        We support 2-dim prefix matching policy at present. Given a typical 5-tuple rule (matching protocol, src_ip, dst_ip, src_port and dst_port), we project it to the 2-dim plane. For example, a rule matching (src_ip, dst_ip, src_port, dst_port, protocol) will be represented as (F(src_ip), F(dst_ip)). We use additional field count to account for multiple rules sharing the same src_ip and dst_ip. For the actions (fwd, drop, modify), we use integers to stand for the different actions (0 for "drop", 1 for "accep.
   
4. Misc
   4.1 Technical report of this project can be found here: http://www.cs.princeton.edu/~nkang/research/con012-kang_full.pdf
   4.2 The path algorithm supports 2-dim prefix matching policy at present. To run the algorithm for >2-dim policy, pre-processing to project policy onto 2-dim plane is needed.
   4.4 The program depends on Gurobi Optimization Tool. http://www.gurobi.com/
   
